//  What we really want is to prime factorize a Loc

// This can be done by either rewriting prime factorization algorithm
// for this ring. This would make me learn a lot, but would quite increase
// the duration of my internship. 
// The advantage would be to reduce external dependencies and perhaps speedup?
//
//
//
//
use num_traits::One;
use num_traits::pow;
use num_traits::Zero;
use num_traits::NumCast;

use std::ops::Rem;

use prime_factorization::Factorization;



use crate::structs::rings::Int; 
use crate::structs::rings::Float; 
use crate::structs::rings::LogDepInt; 
use crate::structs::rings::LocalizableNorm; 
use crate::structs::rings::local_ring::Local; 
use crate::structs::rings::zomega::Zomega;
use crate::structs::rings::zroot2::Zroot2; 
use crate::structs::rings::special_values::sqrt2loc;
use crate::structs::rings::special_values::onebyroot2loc;
use crate::structs::rings::special_values::omega;
use crate::structs::rings::special_values::iota_zomega;
use crate::structs::rings::special_values::sqrt2_zomega;

use crate::algorithms::inexact_synth::SQRT2;

type Loc = Local::<Zroot2>;

type FactorInt = u128;
type FactorPowerInt = u32;


// Generic function to compute gcd given that there is a remainder operation
// Generated by ChatGPT for integers, modified by yours truly
pub fn compute_gcd<T>(x: T, y: T) -> T 
where T: Rem<Output=T>+Copy+Zero+PartialEq
{
    // Initialize a and b to x and y, respectively
    let (mut a, mut b) = (x, y);

    // Repeatedly apply the Euclidean algorithm until the remainder is 0
    while b != T::zero()
    {

        // Divide a by b and find the remainder
        // CAUTION: a % b does not exist uniquely
        //          for Zroot2. It is just some number 
        //          r such that b=a*q+r
        let remainder = a % b;

        // Replace a with b and b with the remainder
        a = b;
        b = remainder;
    }

    return a;
}


// note that here p may not be a prime in the input
pub fn power_mod_p(xorig: Int, m: Int, p: Int ) -> Int
{

    let mut result = 1;
    let mut x = xorig%p;
    let mut n = m ;

    if x==Int::zero()
    {
        // println!("------ ZERO HERE ------ ");
        return Int::zero();
    }

    if p==Int::zero()
    {
        return Int::zero();
    }

    while n > Int::zero() 
    {
        if n & Int::one() == Int::one()
        {
            result *= x;
            result = result %p;
        }
        x *= x;
        x = x%p;
        n >>= 1;
    }

    return result;
}


// Incorrectly generated by ChatGPT
// Fixed by yours truly
pub fn tonelli_shanks(n: Int, p: Int) -> Int {
    // Handle special cases
    if n % p == 0 {
        return 0;
    }
    if p == 2 {
        return n % 2;
    }


    let mut s = 0;
    let mut q = p - 1;
    while q % 2 == 0 
    {

        s += 1;
        q /= 2;
    }

    let mut z = find_quad_nonresidue(p);


    let mut m = s;
    let mut c = power_mod_p(z, q, p);
    let mut t = power_mod_p(n, q, p);
    let mut r = power_mod_p(n, (q + 1) / 2, p);

    while t != 1 {
        let mut i = 0;
        let mut t_i = t;
        while t_i != 1 {
            i += 1;
            t_i = (t_i * t_i) % p;
        }



        let b = power_mod_p(c, power_mod_p(2, m - i - 1, p-1), p);
        m = i;
        c = (b * b) % p;
        t = (t * c) % p;
        r = (r * b) % p;

        if t == 0 
        {
            return 0;
        }
    }

    return r;
}

pub fn find_quad_nonresidue(p: Int) -> Int
{
    // We assume that p is prime and odd
    // assert!(p % 2 == 1 && is_prime(p));

    // if p % 8 == 1 || p % 8 == 7 
    // {
    //     return power_mod_p(p - 1, (p - 1) / 2, p);
    // }

    let mut a = 2;

    while legendre_symbol(a,p)==1
    {
        a += 1;
    }

    return a;
}

pub fn find_quad_residue(p: Int) -> Int
{
    // We assume that p is prime and odd
    // assert!(p % 2 == 1 && is_prime(p));

    // if p % 8 == 1 || p % 8 == 7 
    // {
    //     return power_mod_p(p - 1, (p - 1) / 2, p);
    // }

    let mut a = 2;

    while legendre_symbol(a,p)!=1
    {
        a += 1;
    }

    return a;
}

pub fn legendre_symbol(a: Int,p: Int) -> Int
{
    if p%2==0 
    {
        todo!();
    }

    if a%p == 0
    {
        return 0;
    }

    return power_mod_p(a, (p - 1) / 2, p);

}

// This takes as input a Loc and returns Some((Loc,Loc)) such that the sum of two Locs in the
// output is 1. If no such pairs exist, it returns None
//
// The way to do it is the following. Write our_num = unit * prime_1^power_1 * prime_2^power_2 * ...
// and then try to write each of those factors as sum of two squares (it is known exactly when this
// is impossible).
//
// And then, we use the identity:
//
// (a^2+b^2)*(c^2+d^2) = (ac-bd)^2 + (bc+ad)^2
//
// which is nothing but just 
// (a+ib)(c+id) = (ac-bd) + i(ad+bc)
//
//
pub fn attempt_to_write_this_number_as_sum_of_two_squares_in_loc(our_num: Loc)  -> Option::<(Loc,Loc)>
{
    
    // println!("Input is {}", our_num);

    if our_num.is_zero()
    {
        return Some((Loc::zero(), Loc::zero() ) );
    }

    let factorvec = prime_factorization_of_loc(our_num);
    let mut output = Zomega::one();


    // To be mutliplied later
    let mut power_of_sqrt2 = 0;


    for (prime, locprime,power) in factorvec
    {
        // println!(" --------- \n Thinking about prime {}", prime );
        // println!("power is {}", power );
        // println!("power%2 is {}", power%2 );
        // println!("locprime is {}", locprime );

        if power%2==1 || power%2==-1
        {
            if prime==2
            {
                if power >= 0 
                {
                    let delta = Zomega(1,1,0,0);
                    let deltapower = pow(delta , power.try_into().unwrap() );

                    // println!("deltapower = {}", deltapower );
                    output= output * deltapower;
                }
                else if power < 0
                {
                    
                    let delta = Zomega::one() + omega();
                    let deltapower = pow(delta , (-power).try_into().unwrap() );
                    // println!("deltapower = {}", deltapower );

                    output= output * deltapower;
                    power_of_sqrt2 = power;
                }
            }
            else if prime%4==1 
            {
                // this is the case when the prime splits in z[omega]
                let pint = prime as Int;
                let u = tonelli_shanks(pint - 1,pint);
                
                let uzomega = <Zomega as NumCast>::from(u).unwrap();

                
                let iota = iota_zomega();

                // DEBUG ZONE
                // if locprime.log_den < 0
                // { 
                //     panic!("Unexpected behaviour");
                // }
                // END OF DEBUG ZONE

                let eta = Zomega::from_zroot2(locprime.num);

                let t = compute_gcd(eta,uzomega+iota);
                let t_power = pow(t, power.try_into().unwrap() );
                // println!("t_power {}",t_power );
                // println!("t_powernorm {}",t_power.norm() );
                
                output = output * t_power;

            }
            else if prime%8==3
            {
                // this is the case when the prime splits in z[omega]

                let pint = prime as Int;
                let u = tonelli_shanks( pint - 2, pint ) ;

                let uzomega = <Zomega as NumCast>::from(u).unwrap();
                

                let sqrt2 = sqrt2_zomega();
                let iota = iota_zomega();
                
                // DEBUG ZONE 
                // if locprime.log_den < 0
                // { 
                //     panic!("Unexpected behaviour");
                // }
                // END OF DEBUG ZONE

                let eta = Zomega::from_zroot2(locprime.num);
                let t = compute_gcd(eta, uzomega + iota*sqrt2);
                let t_power = pow(t, power.try_into().unwrap() );

                // println!("t_power {}",t_power );

                output = output * t_power;
            } else
            {
                return None;
            }

        }
        else
        {
            if prime == 2
            {
                power_of_sqrt2 = ( power >> 1 );
                // println!("adjusting power_of_sqrt2 to {}", power_of_sqrt2);
            }
            else 
            {
                let powerby2 = (power >> 1);

                // println!("powerby2 {}", powerby2);
                

                let to_multiply = pow(locprime,powerby2.try_into().unwrap());

                // Debug zone 
                // if locprime.log_den < 0
                // { 
                //     panic!("Unexpected behaviour");
                // }
                // End of debug zone


                let zomega_mult = Zomega::from_zroot2(to_multiply.num);

                // println!("zomega_mult = {}", zomega_mult );

                output = output * zomega_mult;
            }

        }
    }

    // Would have given this as output, but must now take care of 
    // 1. Unit
    // 2. power_of_sqrt2
    let mut left = output.real_part();
    let mut right = output.imag_part();
    
    // Taking care of power_of_sqrt2
    left.log_den = left.log_den - power_of_sqrt2;
    right.log_den = right.log_den - power_of_sqrt2;

    let sum_of_squares_upto_unit = left*left+right*right;

    // println!("sum of squares upto unit {}",sum_of_squares_upto_unit );
    let unit = our_num/sum_of_squares_upto_unit;
    // println!("unit = {}", unit);


    // Time to take care of that unit
    let zrt2_sqrt_unit = find_unit_square_root(unit.num);

    // To be honest, if our_num is doubly positive,
    // there should exist a square root of the unit
    if zrt2_sqrt_unit != None
    {
        output = output * Zomega::from_zroot2(zrt2_sqrt_unit.unwrap());
    }
    else
    {
        panic!("Our unit was not decomposable! This is mathematically impossible if input was doubly positive. Imperfect floats are probably the reason");
        return None;
    }

    // println!("zrt2_sqrt_unit = {}", zrt2_sqrt_unit.unwrap());
    
    // Final left right
    left = output.real_part();
    right = output.imag_part();
    
    // Taking care of power_of_sqrt2 again
    left.log_den = left.log_den - power_of_sqrt2;
    right.log_den = right.log_den - power_of_sqrt2;

    // println!(" left, right are {},{}",left, right );
    // println!(" sum of squares is {}",left*left+ right*right );

    // DEGBUG ZONE
    // if left*left + right*right != our_num
    // {
    //     panic!("We are not quite there");
    // }
    // END OF DEBUG ZONE


    return Some((left,right));

}



// Will keep track of base primes, prime above in Zroot2 and the multiplicty it has
// Warning: Prime factorization does not mean that you will get back your answer if you multiply
// the factors
// The multiplication will differ with the actual answer by a factor of plus-minus one and a power
// of (sqrt2 - 1)
pub fn prime_factorization_of_loc( input: Local::<Zroot2> ) -> Vec::<( FactorInt, Loc, LogDepInt)>
{

    // If this fails, then input is probably out of bound
    let num : FactorInt= input.num.norm().abs().try_into().unwrap();


    // This line here can be replaced by any other prime factorization algorithm
    let factorvec = Factorization::run(num).prime_factor_repr();

    // Take care of powers of two here,
    // they will be ignored in the for loop below
    let mut factorvecloc = vec!((2, sqrt2loc() , -input.log_den));

    if input.log_den == 0
    {
        factorvecloc.pop();
    }

    // println!("=========== \n FACTORING {}", input);
    // println!("norm is {}", num );
    // println!("norm is {}", input.num.0*input.num.0 - 2*input.num.1*input.num.1 );

    for (prime,power) in factorvec
    {
        // println!(" --------- \n Thinking about prime {}", prime );
        // println!("power is {}", power );
        // println!("prime%8 is {}", prime%8 );

        // These are the cases where the prime in Z remains a prime in Zroot2
        if prime%8==3 || prime%8==5
        {

            // This is an inert prime when lifting from Z to Z[sqrt2]
            let primeloc = <Loc as NumCast >::from(prime).unwrap();
            let powerby2 = (power >> 1);
            factorvecloc.push( (prime,primeloc,powerby2.try_into().unwrap() ) );
        }

        // if prime is not 3,5 modulo 8, then it is 1,7 modulo 8
        // These are the cases where the prime in Z splits into two primes in Z[sqrt2]
        else
        {
            // As suggested in the preprint
            // we have primeloc = gcd(prime,x^2+2)
            // where x is a square root of -2 mod p

            let p = < Zroot2 as NumCast>::from(prime).unwrap();
            let pint = prime as Int;

            let u = tonelli_shanks(2,pint);
            let x = Zroot2(u,1);

            let primezrt = compute_gcd(p,x);
            let primezrtconj = primezrt.conj();

            // println!("primezrt found is {}",primezrt );

            let primezrtpowerininput = compute_gcd( input.num, pow(primezrt, power.try_into().unwrap() ) );
            let primezrtconjpowerininput = compute_gcd( input.num, pow(primezrtconj, power.try_into().unwrap() ) );
            //
            // println!("primezrtpowerininput {}", primezrtpowerininput );
            // println!("primezrtconjpowerininput {}", primezrtconjpowerininput );

            if primezrtpowerininput.norm().abs() != 1
            {

                let powerzrt = power_in_zrt2( primezrtpowerininput, primezrt);
                let powerremaining = ( power as LogDepInt)  - powerzrt;

                let primeloc = Local::from_base(primezrt);
                let primelocconj = Local::from_base(primezrtconj);
                if powerzrt > 0
                {
                    factorvecloc.push( (prime,primeloc,powerzrt.try_into().unwrap() ) );
                }
                if powerremaining > 0
                {
                    factorvecloc.push( (prime,primelocconj,powerremaining.try_into().unwrap() ) );
                }
            }
            else
            {
                let primelocconj = Local::from_base(primezrtconj);
                if power > 0
                {
                    factorvecloc.push( (prime,primelocconj,power.try_into().unwrap() ) );
                }
            }


        }
    }

    // println!("------- RETURNING THE VECTOR ------------");
    return factorvecloc;
}


pub fn find_unit_square_root( unit : Zroot2) -> Option::<Zroot2>
{
    let x0 = unit.0 as Float;
    let x1 = unit.1 as Float;

    let r1 = x0 + SQRT2 * x1;
    let r2 = x0 - SQRT2 * x1;

    let lambda = crate::structs::rings::special_values::sqrt2plus1();
    if r1 >= 0.0 && r2 >= 0.0
    {
        if r1 >= 1.0
        {
            let base = SQRT2 + 1.0;
            let mut power = floorlog(r1,base);

            // DEBUG ZONE 
            // if power % 2 !=0 || power < 0
            // {
            //     panic!("Something's not right");
            // }
            // END OF DEBUG ZONE

            return Some( pow( lambda , ( power >> 1 ).try_into().unwrap()  ) );

        }
        else 
        {

            let base = SQRT2 + 1.0;

            let mut power = floorlog(r2,base);

            // DEBUG ZONE 
            // if power % 2 !=0 || power < 0
            // {
            //     panic!("Something's not right");
            // }
            // END OF DEBUG ZONE

            return Some( pow( Zroot2(-1,1), ( power >> 1 ).try_into().unwrap()  ) );
        }

    }
    else 
    {
        println!("x1 x2 were {} {}",x0,x1 );
        println!("r1 r2 were {} {}",r1,r2 );
        println!("The unit {} was not doubly positive", unit );
        return None;
    }
}



// Same thing as taking the log to the base and then floor
// But this is less floating point intensive than the above
pub fn floorlog( input: Float, base: Float) -> LogDepInt
{
    let mut out = 0;
    let mut x = input.clone();
    while (x >= base) 
    {
        out = out + 1;
        x = x / base;
    }
    return out;

}


// WARNING: This function assumes that input is a perfect power of the base (upto unit)
// It then finds the power
pub fn power_in_zrt2(input: Zroot2, base : Zroot2) -> LogDepInt
{
    // An earlier implementation used floorlog
    // But floating points suck when it comes comes to do this kind of stuff

    let mut out = 0;
    let mut x = input.clone();
    while x % base == Zroot2::zero()
    {
        out = out + 1;
        x = x / base
    }
    return out;
}
