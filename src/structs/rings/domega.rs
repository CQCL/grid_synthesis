// Consider the eigth cyclotomic field
// That is the rational field adjoined to the eighth root of unity
// Now conider the fractional ideal generated by 1/2 
// That is what this ring is 
//
//
// Thanks to Kliuchnikov-Maslov-Mosca, we know that all Clifford+T generated gates
// are unitary matrices of elements of this ring




// We bring them in so that we can overload the operators
// Rust must learn how to do arithmetics in our rings
use std::ops::Neg; 
use std::ops::Add; 
use std::ops::Sub; 
use std::ops::Mul; 

// use std::fmt; // To teach rust how to display our ring elements

use crate::structs::rings::dyad::Dyad; //Dyads form DOmega ring elements. This might change.

// Ring of numbers of the form a+b\omega+c\omega^2+d\omega^3
// where \omega is the eighth root of unity
// It should be possible to save memory here by just remembering one denominator of 2 for the
// entire tuple of Dyads. 
// TODO: Think about that
#[derive(Copy, Clone)]
pub struct DOmega(pub Dyad, pub Dyad, pub Dyad, pub Dyad); 
// The Dyads can be called as 
// variable.0, variable.1 and so on



// Conjugate DOmega elements
impl DOmega {
    pub fn conj(self) -> DOmega {
        DOmega(self.0,-self.3, -self.2, -self.1)
    }
}


// Negatation on DOmega
impl Neg for DOmega{
    type Output = DOmega;

    fn neg(self) -> DOmega {
        DOmega(-self.0,-self.1,-self.2,-self.3)
    }
}



// Teaching rust how to add DOmega elements
impl Add for DOmega {
    type Output = DOmega;

    fn add(self, other: DOmega) -> DOmega {
        DOmega(self.0+other.0,self.1+other.1,self.2+other.2,self.3+other.3)
    }
}

// Teaching rust how to subtract DOmega elements
impl Sub for DOmega {
    type Output = DOmega;

    fn sub(self, other: DOmega) -> DOmega {
        self+(-other) //subtraction is just adding the additive inverse
    }
}


// Teaching rust how to multiply DOmega elements
impl Mul for DOmega {
    type Output = DOmega;

    fn mul(self, other: DOmega) -> DOmega {
        DOmega(
            other.0*self.0 - other.1*self.3 - other.2*self.2 - other.3*self.1,
            other.0*self.1 + other.1*self.0 - other.2*self.3 - other.3*self.2,
            other.0*self.2 + other.1*self.1 + other.2*self.0 - other.3*self.3,
            other.0*self.3 + other.1*self.2 + other.2*self.1 + other.3*self.0
            )
    }
}
