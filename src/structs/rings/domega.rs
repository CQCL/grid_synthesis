// Consider the eighth cyclotomic field
// That is the rational field adjoined to the eighth root of unity
// Now conider the fractional ideal generated by 1/2 
// That is what this ring is 
//
//
// Thanks to Kliuchnikov-Maslov-Mosca, we know that all Clifford+T generated gates
// are unitary matrices of elements of this ring


use crate::structs::rings::Conj; //Conjugation trait
// use crate::structs::rings::Constructs; // Construction trait


// We bring them in so that we can overload the operators
// Rust must learn how to do arithmetics in our rings
use std::ops::Neg; 
use std::ops::Add; 
use std::ops::Sub; 
use std::ops::Mul; 

// For display
use std::fmt::Result;
use std::fmt::Display;
use std::fmt::Formatter;

use crate::structs::rings::dyad::Dyad; //Dyads form DOmega ring elements. This might change.

// Ring of numbers of the form a+b\omega+c\omega^2+d\omega^3
// where \omega is the eighth root of unity
// It should be possible to save memory here by just remembering one denominator of 2 for the
// entire tuple of Dyads. 
// TODO: Think about that
#[derive(Debug, Copy, Clone)]
pub struct DOmega(pub Dyad, pub Dyad, pub Dyad, pub Dyad); 
// The Dyads can be called as 
// variable.0, variable.1 and so on



// Conjugate DOmega elements
impl<T> Conj<T> for DOmega {
    fn conj(self) -> DOmega {
        DOmega(self.0,-self.3, -self.2, -self.1)
    }
}

// Nicely display DOmega Matrices
impl Display for DOmega
{
    fn fmt(&self, f: &mut Formatter) -> Result{
        write!(f,"{}+{}w+{}w^2+{}w^3",self.0, self.1, self.2,self.3)
    }
}

// Negatation on DOmega
impl Neg for DOmega{
    type Output = DOmega;

    fn neg(self) -> DOmega {
        DOmega(-self.0,-self.1,-self.2,-self.3)
    }
}


// Teaching rust how to add DOmega elements
impl Add for DOmega {
    type Output = DOmega;

    fn add(self, other: DOmega) -> DOmega {
        DOmega(self.0+other.0,self.1+other.1,self.2+other.2,self.3+other.3)
    }
}

// Teaching rust how to subtract DOmega elements
impl Sub for DOmega {
    type Output = DOmega;

    fn sub(self, other: DOmega) -> DOmega {
        self+(-other) //subtraction is just adding the additive inverse
    }
}


// Teaching rust how to multiply DOmega elements
impl Mul for DOmega {
    type Output = DOmega;

    fn mul(self, other: DOmega) -> DOmega {
        DOmega(
            other.0*self.0 - other.1*self.3 - other.2*self.2 - other.3*self.1,
            other.0*self.1 + other.1*self.0 - other.2*self.3 - other.3*self.2,
            other.0*self.2 + other.1*self.1 + other.2*self.0 - other.3*self.3,
            other.0*self.3 + other.1*self.2 + other.2*self.1 + other.3*self.0
            )
    }
}


// Get zero and one as DOmega numbers
// impl<T> Constructs<T> for DOmega
// {
//     fn one() -> Self {
//         let a0=Constructs::<Dyad>::zero();
//         let a1=Constructs::<Dyad>::one();
//         return DOmega(a1,a0,a0,a0);
//     }
    
//     fn zero() -> Self {
//         let a0=Constructs::<Dyad>::zero();
//         return DOmega(a0,a0,a0,a0);
//     }
// }


// Teaching rust how to compare these ring elements
impl PartialEq for DOmega
{
    fn eq(&self, other: &Self) -> bool {
        // println!("{},{},{},{}",self.0,self.1,self.2,self.3);
        // println!("{},{},{},{}",other.0,other.1,other.2,other.3);
        return self.0==other.0 && self.1==other.1 && self.2==other.2 && self.3==other.3;
    }
}




// To construct DOmega directly from integers
impl From<u32> for DOmega {
    fn from(int: u32) -> Self {
        DOmega(Dyad::from(int), Dyad::from(0), Dyad::from(0), Dyad::from(0))
    }
}
