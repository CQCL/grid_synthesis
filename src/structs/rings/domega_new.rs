// Consider the eighth cyclotomic field
// That is the rational field adjoined to the eighth root of unity
// Now conider the fractional ideal generated by 1/\sqrt{2}
// That is what this ring is 
//
//
// Thanks to Kliuchnikov-Maslov-Mosca, we know that all Clifford+T generated gates
// are unitary matrices of elements of this ring
//
// This current DOmega_new struct is a variant of the previos DOmega struct defined over Dyads
//
// I am using a p-adic valuation with resepct to 1+\omega in the eight-ring of integers and storing
// it as a precomputed number. This is roughly twice of the value of the 
// sde function defined in the KMM paper
//
// I belive that this should make the computations faster. We will see.


use crate::structs::rings::Conj; //Conjugation trait
use crate::structs::rings::Constructs; // Construction trait


// We bring them in so that we can overload the operators
// Rust must learn how to do arithmetics in our rings
use std::ops::Neg; 
use std::ops::Add; 
use std::ops::Sub; 
use std::ops::Mul; 

// For display
use std::fmt::Result;
use std::fmt::Display;
use std::fmt::Formatter;

use crate::structs::rings::dyad::Dyad; //Dyads form DOmega_new ring elements. This might change.

// Ring of numbers of the form (a+b\omega+c\omega^2+d\omega^3)/sqrt(2)^k
// where \omega is the eighth root of unity
// It should be possible to save memory here by just remembering one denominator of 2 for the
// entire tuple of Dyads. 
// TODO: Think about that
#[derive(Debug, Copy, Clone)]
pub struct DOmega_new{ 
    0: i64,
    1: i64,
    2: i64,
    3: i64,
    den_sqrt_2: u32
}; 
// variable.0, variable.1 and so on are intgers


// Conjugate DOmega_new elements
impl<T> Conj<T> for DOmega_new {
    fn conj(self) -> DOmega_new{
        DOmega_new{ 
            0: self.0,
            1: -self.3,
            2: -self.2,
            3: -self.1,
            height: u32
        }
    }
}

// Nicely display DOmega_new Matrices
impl Display for DOmega_new
{
    fn fmt(&self, f: &mut Formatter) -> Result{
        write!(f,"({}+{}w+{}w^2+{}w^3)/(1+w)^{}",self.0, self.1, self.2,self.3,self.height)
    }
}

// Negatation on DOmega_new
impl Neg for DOmega_new{
    type Output = DOmega_new;

    fn neg(self) -> DOmega_new {
        DOmega_new{ 
            0: -self.0,
            1: -self.1,
            2: -self.2,
            3: -self.3,
            height: u32
        }
    }
}


// Teaching rust how to add DOmega_new elements
impl Add for DOmega_new {
    type Output = DOmega_new;

    fn add(self, other: DOmega_new) -> DOmega_new {
        // WRONG CODE!!!! 
        // NEED TO WORK ON THIS
        if self.height ==0 && other.height==0
        {
            DOmega_new{ 
            0: other.0+self.0,
            1: other.1+self.1,
            2: other.2+self.2,
            3: other.3+self.3,
            height: 0
            }
        }
    }
}

// Teaching rust how to subtract DOmega_new elements
impl Sub for DOmega_new {
    type Output = DOmega_new;

    fn sub(self, other: DOmega_new) -> DOmega_new {
        self+(-other) //subtraction is just adding the additive inverse
    }
}


// Teaching rust how to multiply DOmega_new elements
impl Mul for DOmega_new {
    type Output = DOmega_new;

    fn mul(self, other: DOmega_new) -> DOmega_new {
        DOmega_new(
            other.0*self.0 - other.1*self.3 - other.2*self.2 - other.3*self.1,
            other.0*self.1 + other.1*self.0 - other.2*self.3 - other.3*self.2,
            other.0*self.2 + other.1*self.1 + other.2*self.0 - other.3*self.3,
            other.0*self.3 + other.1*self.2 + other.2*self.1 + other.3*self.0
            )
    }
}




// Get zero and one as DOmega_new numbers
impl<T> Constructs<T> for DOmega_new
{
    fn one() -> Self {
        let a0=Constructs::<Dyad>::zero();
        let a1=Constructs::<Dyad>::one();
        return DOmega_new(a1,a0,a0,a0);
    }
    
    fn zero() -> Self {
        let a0=Constructs::<Dyad>::zero();
        return DOmega_new(a0,a0,a0,a0);
    }
}


// Teaching rust how to compare these ring elements
impl PartialEq for DOmega_new
{
    fn eq(&self, other: &Self) -> bool {
        // println!("{},{},{},{}",self.0,self.1,self.2,self.3);
        // println!("{},{},{},{}",other.0,other.1,other.2,other.3);
        return self.0==other.0 && self.1==other.1 && self.2==other.2 && self.3==other.3;
    }
}



// To construct DOmega_new directly from integers
impl From<u32> for DOmega_new {
    fn from(int: u32) -> Self {
        DOmega_new(Dyad::from(int), Dyad::from(0), Dyad::from(0), Dyad::from(0))
    }
}
